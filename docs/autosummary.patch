diff --git a/sphinx/ext/autosummary/__init__.py b/sphinx/ext/autosummary/__init__.py
index 581211996..520083866 100644
--- a/sphinx/ext/autosummary/__init__.py
+++ b/sphinx/ext/autosummary/__init__.py
@@ -58,7 +58,8 @@ import posixpath
 import re
 import sys
 import warnings
-from inspect import Parameter
+from importlib import import_module
+from inspect import Parameter, getmembers, isclass, isfunction
 from os import path
 from types import ModuleType
 from typing import Any, Dict, List, Optional, Tuple, Type, cast
@@ -241,6 +242,25 @@ class Autosummary(SphinxDirective):
     Pretty table containing short signatures and summaries of functions etc.
 
     autosummary can also optionally generate a hidden toctree:: node.
+
+    About a patch:
+
+    Autosummary with autolisting for modules.
+    By default it tries to import all public names (__all__),
+    otherwise import all classes and/or functions in a module.
+
+    Options:
+
+    - :autolist: option to get list of classes and functions from currentmodule.
+    - :autolist-classes: option to get list of classes from currentmodule.
+    - :autolist-functions: option to get list of functions from currentmodule.
+
+    Example Usage:
+
+    .. currentmodule:: ignite.metrics
+    .. autosummary::
+        :nosignatures:
+        :autolist:
     """
 
     required_arguments = 0
@@ -253,9 +273,63 @@ class Autosummary(SphinxDirective):
         'nosignatures': directives.flag,
         'recursive': directives.flag,
         'template': directives.unchanged,
+        "autolist": directives.unchanged,
+        "autolist-classes": directives.unchanged,
+        "autolist-functions": directives.unchanged,
     }
 
     def run(self) -> List[Node]:
+        for auto in ("autolist", "autolist-classes", "autolist-functions"):
+            if auto in self.options:
+                # Get current module name
+                module_name = self.env.ref_context.get("py:module")
+                # Import module
+                module = import_module(module_name)
+
+                # Get public names (if possible)
+                try:
+                    names = getattr(module, "__all__")
+                except AttributeError:
+                    # Get classes defined in the module
+                    cls_names = [
+                        name[0]
+                        for name in getmembers(module, isclass)
+                        if name[-1].__module__ == module_name and not (name[0].startswith("_"))
+                    ]
+                    # Get functions defined in the module
+                    fn_names = [
+                        name[0]
+                        for name in getmembers(module, isfunction)
+                        if (name[-1].__module__ == module_name) and not (name[0].startswith("_"))
+                    ]
+                    names = cls_names + fn_names
+                    # It may happen that module doesn't have any defined class or func
+                    if not names:
+                        names = [name[0] for name in getmembers(module)]
+
+                # Filter out members w/o doc strings
+                names = [name for name in names if getattr(module, name).__doc__ is not None]
+
+                if auto == "autolist":
+                    # Get list of all classes and functions inside module
+                    names = [
+                        name for name in names if (isclass(getattr(module, name)) or isfunction(getattr(module, name)))
+                    ]
+                else:
+                    if auto == "autolist-classes":
+                        # Get only classes
+                        check = isclass
+                    elif auto == "autolist-functions":
+                        # Get only functions
+                        check = isfunction
+                    else:
+                        raise NotImplementedError
+
+                    names = [name for name in names if check(getattr(module, name))]
+
+                # Update content
+                self.content = StringList(names)
+
         self.bridge = DocumenterBridge(self.env, self.state.document.reporter,
                                        Options(), self.lineno, self.state)
 
